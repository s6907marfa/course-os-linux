**Работа с операционной системой в Python. Библиотека os**

#######################################################

date 2021-05-10
 
author Закирова М.С.

.. contents
 
Как писать программы на Python
=================================

Интерактивный режим
---------------------------
В ОС на базе ядра Linux можно программировать на Python в интерактивном режиме с помощью приложения «Терминал», в котором работает командная оболочка Bash. Здесь, чтобы запустить интерпретатор, надо выполнить команду python3.

::

    s690712@s73000:~$ python3
    Python 3.7.1 (default, Dec 14 2018, 19:28:38)
    [GCC 7.3.0] :: Anaconda, Inc. on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>>

Последняя строка ``">>>"`` - приглашение для ввода команд

Создание скриптов
------------------
Несмотря на удобства интерактивного режима, чаще всего необходимо сохранить исходный программный код для последующего выполнения и использования. В таком случае подготавливаются файлы, которые передаются затем интерпретатору на исполнение. 
Файлы с кодом на Python имеют расширение .py.

Для написания скрипта подойдет практически любой текстовый редактор. Здесь создается и сохраняется файл с кодом. Далее его можно запустить на выполнение через терминал. При этом сначала указывается интерпретатор (в данном случае python3), потом имя файла (если файл находится в другом каталоге, то указывается с адресом, или надо перейти в этот каталог с помощью команды cd оболочки Bash).
::

    user:~$ python3 test.py



Модули
==============
Чтобы разрешить проблему доступа к дополнительным возможностям языка, в программировании стало общепринятой практикой использовать так называемые модули, пакеты и библиотеки. Каждый модуль содержит коллекцию функций и классов, предназначенных для решения задач из определенной области.

Так, модуль os ,из стандартной библиотеки языка программирования Python, - это библиотека функций для работы с операционной системой. Методы, включенные в неё позволяют определять тип операционной системы, получать доступ к переменным окружения, управлять директориями и файлами:
    * проверка существования объекта по заданному пути;
    * определение размера в байтах;
    * удаление;
    * переименование и др.

Работа с модулями
------------------
Для доступа к функционалу модуля, его надо импортировать в программу. После импорта интерпретатор "знает" о существовании дополнительных классов и функций и позволяет ими пользоваться.
::

    >>> import os

* Чтобы увидеть перечень функций, входящих в этот модуль, воспользуемся встроенной в Python функцией dir(), передав ей в качестве аргумента имя модуля:

::

    >>> dir(os)
    ['getgid', 'getgrouplist', 'getgroups', 'getloadavg', 'getlogin', 'getpgid', 'getpgrp', 'getpid', 'getppid', 'getpriority', 'getresgid', 'getresuid', 'getsid', 'getuid', 'getxattr', 'initgroups', 'isatty',]



* Если мы не знаем, что делает та или иная функция, то можем получить справочную информацию о ней с помощью встроенной в язык Python функции help()

* Второй способ импорта – это когда импортируется не сам модуль, а только необходимые функции из него:

::

    >>> from os import name, environ
    >>> environ
    environ({'SHELL': '/bin/bash', 'PWD': '/home/s690712', 'LOGNAME': 's690712'..})
    
    
В таком случае при их вызове не надо перед именем функции указывать имя модуля

* Чтобы импортировать сразу все функции из модуля:

::

    >>> from os import *


Функции модуля os
-----------------
Наиболее популярными функциями из модуля os являются те, которые позволяют получать данные о операционной системе, сведения о файлах и папках, хранимых в памяти на жестком диске ПК.

* os.name -в зависимости от установленной ОС, он вернет ее короткое наименование в строковом представлении:

::

    >>> os.name
    'posix'

* os.environ - словарь переменных окружения.

::

    >>> os.environ
    environ({'SHELL': '/bin/bash', 'PWD': '/home/s690712', 'LOGNAME': 's690712', ..})

* По умолчанию рабочей директорией программы является каталог, где содержится документ с ее исходным кодом. Благодаря этому, можно не указывать абсолютный путь к файлу, если тот находится именно в этой папке. Получить сведения о текущей директории позволяет функция getcwd, которая возвращает полный адрес рабочего каталога на жестком диске. 

::

    >>> os.getcwd()
    '/home/s690712'

* os.chdir(path) - смена текущей директории.
* os.listdir(path=".") - список файлов и директорий в папке.

::

    >>> os.listdir()
    ['.gitconfig', 's690712\\one\two', '.bashrc', '.local', '.cache', '.bash_logout', '.lesshst', '.mozilla', '.python_history', 'cat.txt', 'newfail.txt', 'testgit', '.bash_history', '.swp', '.profile', '.config', 'bye.txt', '.git', '.viminfo']

* **os.walk(top, topdown=True, onerror=None, followlinks=False)** - генерация имён файлов в дереве каталогов, сверху вниз (если topdown равен True), либо снизу вверх (если False). Для каждого каталога функция walk возвращает кортеж (путь к каталогу, список каталогов, список файлов).


Возможности модуля os позволяют не только отображать информацию об уже существующих в памяти объектах, но и генерировать абсолютно новые.

* os.mkdir(path) -  создать папку по пути path 
* Благодаря функции makedirs можно создавать сразу несколько новых папок в неограниченном количестве, если предыдущая директория является родительской для следующей. Таким образом, в следующем примере показывается генерация цепочки папок из s690712, one, two.

::

    >>> os.makedirs('s690712\one\two')

* os.remove(path) - удаляет путь к файлу.

Чтобы стереть из памяти папку, следует воспользоваться встроенной функцией rmdir, указав ей адрес объекта. Однако здесь присутствуют определенные нюансы, поскольку программа не позволит беспрепятственно удалить директорию, в которой хранятся другие объекты. В таком случае на экране отобразится ошибка.

* os.rmdir(path) - удаляет пустую директорию.
* os.removedirs(path) - удаляет директорию, затем пытается удалить родительские директории, и удаляет их рекурсивно, пока они пусты.


os предоставляет возможность быстрой смены названия для любого файла или же каталога при помощи метода rename. Данная функция принимает сразу два разных аргумента. Первый отвечает за путь к старому наименованию документа, в то время как второй отвечает за его новое название. В примере показано переименование директории folder в catalog. Стоит помнить, что метод может генерировать исключение, если по указанному пути нет файла.
::

    >>>os.rename("s690712\folder", "s690712\catalog")


Переименовывать можно не только один каталог, но и несколько папок сразу, только если все они находятся в одной иерархической цепочке. Для этого достаточно вызвать метод renames и передать ему путь к конечной директории в качестве первого аргумента. В роли же второго параметра выступает аналогичный адрес к папке, но только с новыми именами всей цепочки.  Переименование директорий folder, first и second в catalog, one и two.

::
   
    >>>os.renames(r"D:\folder\first\second", r"D:\catalog\one\two")


Подмодуль path
~~~~~~~~~~~~~~~~~~~
os.path - реализует некоторые полезные функции на работы с путями.

* Чтобы избежать ошибок, связанных с отсутствием определенного файла или директории, которые должны быть обработаны программой, следует предварительно проверять их наличие с помощью метода exists. Передав ему в качестве аргумента путь к нужному файлу или папке, можно рассчитывать на лаконичный ответ в виде булевого значения true/false, сообщающего о наличии/отсутствии указанного объекта в памяти компьютера.

::

    >>> os.path.exists('\s690712\hello.txt')
    False

* os.path.isabs(path) - является ли путь абсолютным.

* os.path.isfile(path) - является ли объект по пути path файлом.

* os.path.isdir(path) -  является ли объект по пути path директорией.

* os.path.islink(path) - является ли объект по пути path символической ссылкой.
* os.path.getsize(path) - размер файла по пути path в байтах.
* os.path.abspath(path) - возвращает абсолютный путь по относительному.

Иногда для взаимодействия с документом необходимо получить его полное имя, включающее разрешение, но не абсолютный путь к нему на диске. Преобразовать адрес объекта в название позволяет функция basename
::

    >>> os.path.basename("/home/s690712/bye.txt")
    'bye.txt'
    
Обратная ситуация возникает тогда, когда пользователю нужно получить только путь к файлу, без самого названия объекта:

::

    >>> os.path.dirname("/home/s690712/bye.txt")
    '/home/s690712'
    
* os.path.split(path) - разбивает путь на кортеж (голова, хвост), где хвост - последний компонент пути, а голова - всё остальное. Хвост никогда не начинается со слеша (если путь заканчивается слешем, то хвост пустой). Если слешей в пути нет, то пустой будет голова.

::

    >>> os.path.split("/home/s690712/bye.txt")
    ('/home/s690712', 'bye.txt')

* Обратно os.path.join(path1, path2) - соединяет пути с учётом особенностей операционной системы.

::

    >>> os.path.join('/home/s690712', 'bye.txt')
    '/home/s690712/bye.txt'

* os.path.relpath(path, start=None) - вычисляет путь относительно директории start (по умолчанию - относительно текущей директории).

* os.path.samefile(path1, path2) - указывают ли path1 и path2 на один и тот же файл или директорию

::

    s690712@s73000:~$ cd hel
    s690712@s73000:~/hel$ echo bye> hello.txt
    s690712@s73000:~/hel$ cd ..
    s690712@s73000:~$ python3
    Python 3.7.1 (default, Dec 14 2018, 19:28:38)
    [GCC 7.3.0] :: Anaconda, Inc. on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>> import os
    >>> os.path.samefile("hel",".")
    False

Создание собственного модуля
===============================
Когда интерпретатор Питона встречает команду импорта, то просматривает на наличие файла-модуля определенные каталоги. Их перечень можно увидеть по содержимому sys.path:

::

    >>> import sys
    >>> sys.path
    ['', '/home/s690712/lib/python37.zip', '/lib/python3.7', '/lib/python3.7/lib-dynload', '/lib/python3.7/site-packages', '//lib/python3.7/site-packages']

Это список адресов в Linux. Первый элемент – пустая строка, что обозначает текущий каталог, то есть то место, где сохранена сама программа, импортирующая модуль. Если вы сохраните файл-модуль и файл-программу в одном каталоге, то интерпретатор без труда найдет модуль.

В качестве тренировки создадим модуль с функциями для вычисления площадей прямоугольника, треугольника и круга, поместим его в отдельный файл square.py, a сам файл потом передадим в sys.path:

::

    s690712@s73000:~$ vim square.py
    -
    #! python3
    from math import pi, pow
     
    def rectangle(a, b):
        return round(a * b, 2)
     
    def triangle(a, h):
        return round(0.5 * a * h, 2)
     
    def circle(r):
        return round(pi * pow(r, 2), 2) 

Исполняемая программа count будет считать площадь круга по переданному ей значению радиуса. Ее код включает инструкцию импорта circle из модуля square.

::

    s690712@s73000:~$ vim count.py
    -
    #! python3
    from square import circle
    print(circle(int(input())))
    -
    s690712@s73000:~$ python3
    Python 3.7.1 (default, Dec 14 2018, 19:28:38)
    [GCC 7.3.0] :: Anaconda, Inc. on linux
    Type "help", "copyright", "credits" or "license" for more information.
    >>> import sys
    >>> sys.path.insert(0,'/home/s690712/square.py')
    >>>
    [1]+  Остановлен    python3
    s690712@s73000:~$ python3 count.py
    3
    28.27

   
